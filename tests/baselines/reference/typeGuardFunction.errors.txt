tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(103,12): error TS2322: Type 'string' is not assignable to type 'x is A'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(106,55): error TS1220: Can't define a type-guard type inside a type-guard type.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(110,32): error TS2304: Cannot find name 'x'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(114,48): error TS1219: Type declaration expected.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(118,38): error TS2504: Type-guard target must have a matching parameter.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(122,51): error TS2322: Type 'B' is not assignable to type 'A'.
  Property 'kind' is missing in type 'B'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(126,56): error TS2322: Type 'number' is not assignable to type 'string'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(130,56): error TS2322: Type 'T[]' is not assignable to type 'string'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(135,7): error TS2339: Property 'baz' does not exist on type 'A'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(139,5): error TS2322: Type 'Foo' is not assignable to type 'string'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(143,7): error TS2339: Property 'foo' does not exist on type 'A'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(150,7): error TS2339: Property 'foo' does not exist on type 'A'.
tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts(157,46): error TS2345: Argument of type '(x: A) => x is Foo' is not assignable to parameter of type '(item: any) => item is Baz'.
  Type 'x is Foo' is not assignable to type 'item is Baz'.
    Type 'Foo' is not assignable to type 'Baz'.
      Property 'baz' is missing in type 'Foo'.


==== tests/cases/conformance/expressions/typeGuards/typeGuardFunction.ts (13 errors) ====
    
    class A {
        kind: number;
    }
    
    class B {
    }
    
    class Foo extends A {
        foo() {
        }
    }
    
    class Bar extends A {
        bar() {
        }
    }
    
    class Baz extends B {
        baz() {
        }
    }
    
    function isFoo(x: A): x is Foo {
        return true;
    }
    
    function isBar(x: A): x is Bar {
        return true;
    }
    
    function isBaz(x: B): x is Baz {
        return true;
    }
    
    function isArrayOf_1<T>(of: (item) => T, a: any[]): a is T[] {
        return true;
    }
    
    function isArrayOf_2<T>(of: (item) => item is T, a: any[]): a is T[] {
        return true;
    }
    
    declare function getObjectOfType<T>(of: (item: any) => item is T, obj: any[]): T;
    
    function foo(): Foo {
        return <Foo>a;
    }
    
    var a: A;
    var b: B;
    
    if (isFoo(a)) {
        a.foo();
    }
    if(isFoo(a)) {
        a.foo();
    }
    
    if (isBar(a)) {
        a.bar();
    }
    
    if (isBar(a)) {
        var alias = a;
        alias.bar();
    }
    
    var As: A[];
    if (isArrayOf_1(foo, As)) {
        As[0].foo();
    }
    if (isArrayOf_2(isFoo, As)) {
        As[0].foo();
    }
    
    function hasMultipleParameters(x: any, y): x is Foo {
        return true;
    }
    
    // The parameter index and argument index for the type guard target is matching.
    if (hasMultipleParameters(a, 0)) {
        a.foo();
    }
    
    function hasAMatchingParameterTypeWithTypeGuardType(x: A): x is A {
        return true;
    }
    
    function acceptingBoolean(a: boolean) {
    }
    acceptingBoolean(isFoo(a));
    
    function acceptingTypeGuardFunction(a: (item) => item is Foo) {
    }
    acceptingTypeGuardFunction(isFoo);
    
    /**
     * Errors
     */
    
    function hasANonBooleanReturnStatement(x): x is A {
        return '';
               ~~
!!! error TS2322: Type 'string' is not assignable to type 'x is A'.
    }
    
    function hasTypeGuardTypeInsideTypeGuardType(x): x is x is A {
                                                          ~~~~~~
!!! error TS1220: Can't define a type-guard type inside a type-guard type.
        return true;
    }
    
    function isMissingIsKeyword(): x {
                                   ~
!!! error TS2304: Cannot find name 'x'.
        return true;
    }
    
    function isMissingTypeInTypeGuardType(x): x is {
                                                   ~
!!! error TS1219: Type declaration expected.
        return true;
    }
    
    function hasNonMatchingParameter(y): x is A {
                                         ~
!!! error TS2504: Type-guard target must have a matching parameter.
        return true;
    }
    
    function hasNonMatchingParameterType1(x: A): x is B {
                                                      ~
!!! error TS2322: Type 'B' is not assignable to type 'A'.
!!! error TS2322:   Property 'kind' is missing in type 'B'.
        return true;
    }
    
    function hasNonMatchingParameterType2(x: string): x is number {
                                                           ~~~~~~
!!! error TS2322: Type 'number' is not assignable to type 'string'.
        return true;
    }
    
    function hasNonMathcingGenericType<T>(a: string): a is T[] {
                                                           ~~~
!!! error TS2322: Type 'T[]' is not assignable to type 'string'.
        return true;
    }
    
    if (isBaz(b)) {
        a.baz(); // Error
          ~~~
!!! error TS2339: Property 'baz' does not exist on type 'A'.
    }
    
    // Error: Type Foo is not assignable to string
    var f: string = getObjectOfType(isFoo, [1, 2]); 
        ~
!!! error TS2322: Type 'Foo' is not assignable to type 'string'.
    
    // The parameter index and argument index for the type guard target is not matching.
    if (hasMultipleParameters(0, a)) {
        a.foo(); // Error
          ~~~
!!! error TS2339: Property 'foo' does not exist on type 'A'.
    }
    
    function hasNoTypeGuard(x) {
    }
    
    if (hasNoTypeGuard(a)) {
        a.foo(); // Error
          ~~~
!!! error TS2339: Property 'foo' does not exist on type 'A'.
    }
    
    // Only do a return type type checking. Because parameters are currently
    // not signature checked in a general callback.
    function acceptingDifferentSignatureTypeGuardFunction(a: (item) => item is Baz) {
    }
    acceptingDifferentSignatureTypeGuardFunction(isFoo);
                                                 ~~~~~
!!! error TS2345: Argument of type '(x: A) => x is Foo' is not assignable to parameter of type '(item: any) => item is Baz'.
!!! error TS2345:   Type 'x is Foo' is not assignable to type 'item is Baz'.
!!! error TS2345:     Type 'Foo' is not assignable to type 'Baz'.
!!! error TS2345:       Property 'baz' is missing in type 'Foo'.